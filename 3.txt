TOSSIM:
TOSSIM is a discrete event simulator for TinyOS sensor networks. Instead of compiling a TinyOS application for a mote, users can compile it into the TOSSIM framework, which runs on a PC. This allows users to debug, test, and analyse algorithms in a controlled & repeatable environment. As TOSSIM runs on a PC, users can examine their TinyOS code using debuggers and other development tools.
•	Fidelity: TOSSIM captures TinyOS’ behaviour at a very low level. It simulates the network at the bit level, simulates each individual ADC capture, and every interrupt in the system.
•	Time: While TOSSIM precisely times interrupts (allowing things like bit-level radio simulation), it does not model execution time. From TOSSIM’s perspective, a piece of code runs instantaneously.as the code runs instantaneously, the event that would allow the spin to stop will not occur until the code completes (never).
•	Models: TOSSIM itself does not model the real world. Instead, it provides abstractions of certain real-world phenomena (such as bit error). With tools outside the simulation itself, users can then manipulate these abstractions to implement whatever models they want to use. By making complex model exterior to the simulation, TOSSIM remains flexible to the needs of many users without trying to establish what is “correct.” Additionally, it keeps the simulation simple and efficient.
Radio: TOSSIM does not model radio propagation; instead, it provides a radio abstraction of directed independent bit errors between two nodes. An external program can provide a desired radio model and map it to these bit errors. Having directed bit error rates means that asymmetric links can be easily modelled. Independent bit errors mean longer packets have a higher probability of corruption, and each packet’s loss probability is independent.
Power/Energy: TOSSIM does not model power draw or energy consumption. However, it is very simple to add annotations to components that consume power to provide information on when their power states change (e.g., turned on or off). After a simulation is run, a user can apply a energy or power model to these transitions, calculating overall energy consumption. Because TOSSIM does not model CPU execution time, it cannot easily provide accurate information for calculating CPU energy consumption.
•	Building: TOSSIM builds directly from TinyOS code. To simulate a protocol or system, you must write a TinyOS implementation of it. On one hand, this is often more difficult than an abstract simulation; on the other, it means you can then take your implementation and run it on actual motes.
•	Imperfections: Although TOSSIM captures TinyOS behaviour at a very low level, it makes several simplifying assumptions. This means that it is very possible that code which runs in a simulation might not run on a real mote.
•	Networking: Currently, TOSSIM simulates the 40Kbit RFM mica networking stack, including the MAC, encoding, timing, and synchronous acknowledgements.
•	Authority: Initial experience from real-world deployments has shown that TinyOS networks have very complex and highly variable behaviour. While TOSSIM is useful to get a sense of how algorithms perform in comparison to one another, TOSSIM results shouldn’t be considered authoritative.
MOTE-MOTE Radio Communication
TinyOS provides several interfaces to abstract the underlying communications services and several components that provide these interfaces. All these interfaces and components use a common message buffer abstraction, which is implemented as a nesC struct (like a C struct). The message_t abstraction replaces the TinyOS abstraction. Unlike TinyOS, the
members of message_t are opaque, and therefore not accessed directly. Rather, message_t is an abstract data type.
Basic Communications Interfaces
There are several interfaces and components that use message_t as the underlying data structure. Let's look at some of the interfaces that are in the tos/interfaces directory to familiarize ourselves with the general functionality of the communications system:
•	Packet - Provides the basic accessors for the message_t abstract data type. This interface provides commands for clearing a message's contents, getting its payload length, and getting a pointer to its payload area.
•	Send - Provides the basic address-free message sending interface. This interface provides commands for sending a message and canceling a pending message send. The interface provides an event to indicate whether a message was sent successfully or not. It also provides convenience functions for getting the message's maximum payload as well as a pointer to a message's payload area.
•	Receive - Provides the basic message reception interface. This interface provides an event for receiving messages. It also provides, for convenience, commands for getting a message's payload length and getting a pointer to a message's payload area.
•	PacketAcknowledgements - Provides a mechanism for requesting acknowledgements on a per-packet basis.
•	RadioTimeStamping - Provides time stamping information for radio transmission and reception.
Active Message Interfaces
Since it is very common to have multiple services using the same radio to communicate, TinyOS provides the Active Message (AM) layer to multiplex access to the radio. The term "AM type" refers to the field used for multiplexing. AM types are similar in function to the Ethernet frame type field, IP protocol field, and the UDP port in that all of them are used to multiplex access to a communication service. An AM packet also includes a destination field, which stores an "AM address" to address packets to particular motes. Additional interfaces, also located in the tos/interfaces directory, were introduced to support the AM services:
•	AMPacket - Like Packet, provides the basic AM accessors for the message_t abstract data type. This interface provides commands for getting a node's AM address, an AM packet's destination, and an AM packet's type. Commands are also provided for setting an AM packet's destination and type and checking whether the destination is the local node.
•	AMSend - Similar to Send, provides the basic Active Message sending interface. The key difference between AM Send and Send is that AM Send takes a destination AM address in its send command.
The AM address of a node can be set at installation time, using the make install. n or make reinstall commands. It can be changed at runtime using the Active Message Address C component

MOTE-PC SERIAL COMMUNICATION
The first step is to check that you can get your PC to communicate with a mote. Most motes have a serial port or similar interface. For example, the mica family can directly control a serial port: programming boards basically connect the mote's serial port pins to the actual serial port on the board. Telos motes also have a serial interface, but it talks to their USB hardware, which is similar in functionality but very different in terms of cables and connectors.
The basic abstraction for mote-PC communication is a packet source. A packet source is exactly that: a communication medium over which an application can receive packets from and send packets to a mote.
The first step to testing your serial port is to install the apps/tests/TestSerial application on a mote. This application sends a packet to the serial port every second, and when it receives a packet over the serial port it displays the packet's sequence number on the LEDs.
Once you have installed TestSerial, you need to run the corresponding Java application that communicates with it over the serial port. This is built when you build the TinyOS application. From in the application directory, type:
$ java TestSerial
TestSerial will fall back to a default, which is a Serial Forwarder. Since you don't have a Serial Forwarder running, TestSerial will exit, complaining that it can't connect to one. So, let's specify the serial port as the source, using the -comm parameter as described above. The syntax for a serial port source is as follows:
serial@<PORT>:<SPEED>


PORT depends on your platform and where you have plugged the mote in. For Windows/Cygwin platforms, it is COMN, where N is the port number.
MOTECOM:
If you do not pass a -comm parameter, then tools will check the MOTECOM environment variable for a packet source, and if there is no MOTECOM, they default to a Serial Forwarder. This means that if you're always communicating with a mote over your serial port, you can just set MOTECOM and no longer must specify the -comm parameter. 